using System;
using System.Collections.Generic;
using System.Text;
using IOKode.OpinionatedFramework.SourceGenerators.Helpers;
using Microsoft.CodeAnalysis;

namespace IOKode.OpinionatedFramework.SourceGenerators.RestResourceControllers;

public partial class SourceGenerator
{
    public enum ResourceType
    {
        Retrieve,
        List,
        Create,
        Update,
        Replace,
        Delete,
        Action
    }

    public class GeneratorContextData
    {
        public required ITypeSymbol CommandBaseSymbol;
        public required ITypeSymbol GenericCommandBaseSymbol;

        public readonly IReadOnlyDictionary<string, ResourceType> ResourceTypes = new Dictionary<string, ResourceType>
        {
            ["IOKode.OpinionatedFramework.Resources.Attributes.RetrieveAttribute"] = ResourceType.Retrieve,
            ["IOKode.OpinionatedFramework.Resources.Attributes.ListAttribute"] = ResourceType.List,
            ["IOKode.OpinionatedFramework.Resources.Attributes.CreateAttribute"] = ResourceType.Create,
            ["IOKode.OpinionatedFramework.Resources.Attributes.UpdateAttribute"] = ResourceType.Update,
            ["IOKode.OpinionatedFramework.Resources.Attributes.ReplaceAttribute"] = ResourceType.Replace,
            ["IOKode.OpinionatedFramework.Resources.Attributes.DeleteAttribute"] = ResourceType.Delete,
            ["IOKode.OpinionatedFramework.Resources.Attributes.ActionAttribute"] = ResourceType.Action,
        };
    }

    public class ResourceControllerData
    {
        public required CommandData[] CommandsData { get; set; }
        public string Resource => CommandsData[0].LowerCaseResource;
        public string ClassName => $"{CommandsData[0].PascalCaseResource}ResourceController";
        public string ClassFileName => $"{ClassName}.g.cs";
    }

    public class CommandData
    {
        public required string Resource { get; set; }
        public required string ClassName { get; set; }
        public required string Namespace { get; set; }
        public required ResourceType ResourceType { get; set; }
        public string? KeyName { get; set; }
        public string? Action { get; set; }
        public string? GenericArgument { get; set; }
        public ConstructorParameter[] ConstructorParameters { get; set; } = Array.Empty<ConstructorParameter>();
        public string? ConstructorKeyName => ConstructorParameters.Length > 0 ? ConstructorParameters[0].Name : null;
        public string FullClassName => $"{Namespace}.{ClassName}";
        public string PascalCaseResource => Resource.ToPascalCase();
        public string LowerCaseResource => Resource.ToCamelCase().ToLower();

        public string HttpVerb => ResourceType switch
        {
            ResourceType.Retrieve => "Get",
            ResourceType.List => "Get",
            ResourceType.Create => "Post",
            ResourceType.Update => "Patch",
            ResourceType.Replace => "Put",
            ResourceType.Delete => "Delete",
            ResourceType.Action => "Post", // todo patch?
            _ => throw new ArgumentOutOfRangeException()
        };

        public string HttpAttribute => ResourceType switch
        {
            ResourceType.Create => $"[Http{HttpVerb}]",
            _ => string.IsNullOrEmpty(HttpRoute) ? $"[Http{HttpVerb}]" : $"[Http{HttpVerb}(\"{HttpRoute}\")]"
        };

        public string HttpRoute
        {
            get
            {
                var builder = new StringBuilder();
                if (KeyName != null)
                {
                    builder.Append($"{KeyName.ToKebabCase()}/");
                }

                if (ConstructorKeyName != null)
                {
                    builder.Append($"{{{ConstructorKeyName}}}/");
                }

                if (Action != null)
                {
                    builder.Append(Action.ToKebabCase());
                }

                return builder.ToString();
            }
        }

        public string ControllerMethodName
        {
            get
            {
                var builder = new StringBuilder();
                builder.Append(HttpVerb);

                if (KeyName != null)
                {
                    builder.Append(KeyName.ToPascalCase());
                }

                if (Action != null)
                {
                    builder.Append(Action.ToPascalCase());
                }

                builder.Append("Async");
                return builder.ToString();
            }
        }
    }

    public class ConstructorParameter
    {
        public required string Name { get; set; }
        public required string Type { get; set; }
    }

    private static readonly string ControllerClassTemplate =
        """
        // This file was auto-generated by a source generator
        using System;
        using System.Threading;
        using System.Threading.Tasks;
        using IOKode.OpinionatedFramework.Commands;
        using IOKode.OpinionatedFramework.Facades;
        using IOKode.OpinionatedFramework.Persistence.UnitOfWork.QueryBuilder.Exceptions;
        using Microsoft.AspNetCore.Http;
        using Microsoft.AspNetCore.Mvc;

        namespace IOKode.OpinionatedFramework.Test.Commands;

        [ApiController]
        [Route("{{ Resource }}")]
        public partial class {{ ClassName }} : Controller
        {
            {{~ for command in CommandsData ~}}
            {{ command.HttpAttribute }}
            public async Task<IActionResult> {{ command.ControllerMethodName }}({{ for parameter in command.ConstructorParameters }}{{ parameter.Type }} {{ parameter.Name }}, {{ end }}CancellationToken cancellationToken)
            {
                var commandExecutor = Locator.Resolve<ICommandExecutor>();
                var command = new {{ command.FullClassName }}({{ for parameter in command.ConstructorParameters }}{{ parameter.Name }}{{ if !for.last }}, {{ end }}{{ end }});
                try
                {
                    {{~ if command.GenericArgument ~}}
                    var result = await commandExecutor.InvokeAsync<{{ command.FullClassName }}, {{ command.GenericArgument }}>(command, cancellationToken);
                    return Ok(result);
                    {{~ else ~}}
                    await commandExecutor.InvokeAsync<{{ command.FullClassName }}>(command, cancellationToken);
                    return Ok();
                    {{~ end ~}}
                }
                catch (EntityNotFoundException)
                {
                    return NotFound();
                }
                catch (EmptyResultException)
                {
                    return NotFound();
                }
                catch (NonUniqueResultException)
                {
                    return Problem
                    (
                        title: "Internal Server Error",
                        detail: "Multiple results found when expecting a unique result.",
                        statusCode: StatusCodes.Status500InternalServerError
                    );
                }
                catch (Exception ex)
                {
                    Log.Error(ex, "An unexpected error occurred.");
                    return Problem
                    (
                        title: "Internal Server Error",
                        detail: "An unexpected error occurred. Please contact support if the problem persists.",
                        statusCode: StatusCodes.Status500InternalServerError
                    );
                }
            }
            {{~ end ~}}
        }
        """;
}